<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="SDForest">
<title>Algorithm • SDForest</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js" integrity="sha512-7O5pXpc0oCRrxk8RUfDYFgn0nO1t+jLuIOQdOMRp4APB7uZ4vSjspzp5y6YDtDs4VzUSTbWzBFZ/LKJhnyFOKw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Algorithm">
<meta property="og:description" content="SDForest">
<meta property="og:image" content="https://markusul.github.io/SDForest/logo.png">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light" data-bs-theme="light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">SDForest</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="../articles/SDForest.html">Get started</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="active nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <a class="dropdown-item" href="../articles/Algorithm.html">Algorithm</a>
    <a class="dropdown-item" href="../articles/Runtime.html">Runtime</a>
    <a class="dropdown-item" href="../articles/SDTree.html">SDTree</a>
  </div>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav"></ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Algorithm</h1>
            
      
      
      <div class="d-none name"><code>Algorithm.Rmd</code></div>
    </div>

    
    
<p>A regression tree is part of the function class of step functions
<span class="math inline">\(f(X) = \sum_{m = 1}^M 1_{\{X \in R_m\}}
c_m\)</span>, where (<span class="math inline">\(R_m\)</span>) with
<span class="math inline">\(m = 1, \ldots, M\)</span> are regions
dividing the space of <span class="math inline">\(\mathbb{R}^p\)</span>
into <span class="math inline">\(M\)</span> rectangular parts. Each
region has response level <span class="math inline">\(c_m \in
\mathbb{R}\)</span>. For the training data, we can write the step
function as <span class="math inline">\(f(\mathbf{X}) = \mathcal{P}
c\)</span> where <span class="math inline">\(\mathcal{P} \in \{0, 1\}^{n
\times M}\)</span> is an indicator matrix encoding to which region an
observation belongs and <span class="math inline">\(c \in
\mathbb{R}^M\)</span> is a vector containing the levels corresponding to
the different regions. This function then minimizes <span class="math display">\[(\hat{\mathcal{P}}, \hat{c}) =
\text{argmin}_{\mathcal{P}' \in \{0, 1\}^{n \times M}, c' \in
\mathbb{R}^ {M}} \frac{||Q(\mathbf{Y} - \mathcal{P'}
c')||_2^2}{n}\]</span> We find <span class="math inline">\(\hat{\mathcal{P}}\)</span> by using the tree
structure and repeated splitting of the leaves, similar to the original
cart algorithm <span class="citation">(Breiman et al. 2017)</span>.
Since comparing all possibilities for <span class="math inline">\(\mathcal{P}\)</span> is impossible, we let a tree
grow greedily. Given the current tree, we iterate over all leaves and
all possible splits. We choose the one that reduces the spectral loss
the most, using the SDTree subroutine, and estimate after each split all
the leave estimates <span class="math inline">\(\hat{c} =
\text{argmin}_{c' \in \mathbb{R}^M} \frac{||Q\mathbf{Y} -
Q\mathcal{P} c'||_2^2}{n}\)</span> which is just a linear regression
problem. This is repeated until the loss decreases less than a minimum
loss decrease after a split. The minimum loss decrease equals a
cost-complexity parameter <span class="math inline">\(cp\)</span> times
the initial loss when only an overall mean is estimated. The
cost-complexity parameter <span class="math inline">\(cp\)</span>
controls the complexity of a regression tree and acts as a
regularization parameter.</p>
<p><img src="figures/SDTreeAlg.jpg"></p>
<div class="section level3">
<h3 id="sdtree-subroutine">SDTree subroutine<a class="anchor" aria-label="anchor" href="#sdtree-subroutine"></a>
</h3>
<p>At step <span class="math inline">\(m\)</span>, the tree has <span class="math inline">\(m\)</span> leaves. We encode this by a matrix
<span class="math inline">\(\mathcal{P}\in \mathbb R^{n\times
m}\)</span>. We write <span class="math inline">\(e_1, \ldots,
e_m\)</span> for the columns of <span class="math inline">\(\mathcal{P}\)</span>. The matrix <span class="math inline">\(\mathcal{P}\)</span> has the property that if
<span class="math inline">\(1\leq l&lt;t\leq m\)</span>, either <span class="math inline">\(e_l\)</span> and <span class="math inline">\(e_t\)</span> have disjoint support or the support
of <span class="math inline">\(e_t\)</span> is contained in the support
of <span class="math inline">\(e_l\)</span>. To find the best <span class="math inline">\((m+1)\)</span>th split, we consider a large number
of candidate split encoded by a new column <span class="math inline">\(e_{m+1}\)</span>, which has a <span class="math inline">\(1\)</span> in the <span class="math inline">\(i\)</span>th entry if the <span class="math inline">\(i\)</span>th sample point <span class="math inline">\(x_i\)</span> lies in the new leaf. We want to find
the new column such that <span class="math inline">\(\|Q\mathcal{P}_{m+1}\hat\beta_{m+1}-QY\|_2^2\)</span>
is minimal among the candidate splits, with <span class="math inline">\(\mathcal{P}_{m+1} = (\mathcal{P}_m, e_{m+1})\in
\mathbb R^{n\times ({m+1})}\)</span> and <span class="math inline">\(\hat\beta_{m+1}\)</span> is the least squares
estimator of <span class="math inline">\(QY\)</span> vs. <span class="math inline">\(Q\mathcal{P}_{m+1}\)</span>. The goal of this note
is to show, how we can efficiently find the best split <span class="math inline">\(e_{m+1}\)</span> without having to estimate a
linear model “from scratch” each time.</p>
<p>By induction, assume that we are given a QR-decomposition of the
matrix <span class="math inline">\(Q\mathcal{P}_m\)</span>, i.e. there
exists a matrices <span class="math inline">\(U_m\in \mathbb R^{n\times
m}\)</span> and <span class="math inline">\(R_m\in \mathbb R^{m\times
m}\)</span> such that the columns <span class="math inline">\(u_1,\ldots, u_m\)</span> of <span class="math inline">\(U_m\)</span> are orthonormal and <span class="math inline">\(R_m\)</span> is an upper triangular matrix and
<span class="math display">\[Q\mathcal{P}_m = U_mR_m.\]</span> For a
candidate split encoded by <span class="math inline">\(e_{m+1}\)</span>,
let <span class="math inline">\(w_{m+1}=Qe_{m+1}\)</span>. Define <span class="math display">\[u_{m+1}' = w_{m+1}- (w_{m+1}^T u_1)u_1-\ldots
- (w_{m+1}^T u_m)u_m.\]</span> Then, define <span class="math inline">\(u_{m+1} = u_{m+1}'/\|u_{m+1}'\|\)</span>.
Note that Note that <span class="math inline">\(u_{m+1}\)</span> is
orthogonal to <span class="math inline">\(u_1,\ldots, u_m\)</span>.
Moreover, <span class="math inline">\(w_{m+1}\)</span> is in the span of
<span class="math inline">\(u_1,\ldots, u_{m+1}\)</span> and <span class="math inline">\(w_{m+1} = (w_{m+1}^T u_1)u_1+\ldots+(w_{m+1}^T
u_{m+1})u_{m+1}\)</span>. Define <span class="math inline">\(r_{m+1} =
(w_{m+1}^T u_1,\ldots, w_{m+1}^T u_{m+1})^T\in \mathbb R^{m+1}\)</span>.
In total, we can write <span class="math display">\[Q\mathcal{P}_{m+1}
=  U_{m+1} R_{m+1},\]</span> where <span class="math inline">\(U_{m+1}\)</span> has orthonormal columns <span class="math inline">\(u_1,\ldots, u_{m+1}\)</span> and <span class="math display">\[R_{m+1} = \begin{pmatrix}
    R_m &amp; r_{m+1}\\
    0 &amp; \vdots
\end{pmatrix}\]</span> is an upper triangular matrix. The least squares
estimator <span class="math inline">\(\hat\beta_{m+1}=\arg\min_\beta\|Q\mathcal{P}_{m+1}\beta-QY\|^2\)</span>
is given by <span class="math display">\[\begin{align*}
    \hat\beta_{m+1} &amp;=
((Q\mathcal{P}_{m+1})^TQ\mathcal{P}_{m+1})^{-1}(Q\mathcal{P}_{m+1})^T
QY\\
    &amp;= (R_{m+1}^TU_{m+1}^TU_{m+1}R_{m+1})^{-1}R_{m+1}^TU_{m+1}^T
QY\\
    &amp;=R_{m+1}^{-1}U_{m+1}^T QY
\end{align*}\]</span> We are interested in choosing <span class="math inline">\(e_{m+1}\)</span> such that <span class="math inline">\(\|Q\mathcal{P}_{m+1}\hat\beta_{m+1}-QY\|_2^2\)</span>
is minimal. Note that <span class="math display">\[\begin{align*}
    \|Q\mathcal{P}_{m+1}\hat\beta_{m+1}-QY\|_2^2 &amp;=
\|U_{m+1}R_{m+1}R_{m+1}^{-1} U_{m+1}^T QY-QY\|_2^2 \\
    &amp;= \|U_{m+1}U_{m+1}^TQY-QY\|_2^2\\
    &amp;=(QY)^T(I-U_{m+1}U_{m+1}^T)^2QY\\
    &amp;=(QY)^T(I-U_{m+1}U_{m+1}^T)QY\\
    &amp;=\|QY\|^2-\|U_{m+1}^TQY\|^2\\
    &amp;=\|QY\|^2-\|U_m^TQY\|^2-(u_{m+1}^TQY)^2
\end{align*}\]</span> Hence, we need to choose <span class="math inline">\(e_{m+1}\)</span> such that <span class="math inline">\((u_{m+1}^TQY)^2\)</span> is maximal.</p>
<p>Hence, the algorithm to find the optimal split <span class="math inline">\(e_{m+1}\)</span> has the following steps:</p>
For all candidate splits <span class="math inline">\(s\)</span>, let
<span class="math inline">\(e_{m+1}^s\)</span> be the encoding of this
split. For all <span class="math inline">\(s\)</span>, do
<p>Choose <span class="math inline">\(s\)</span>, such that <span class="math inline">\(\alpha_s\)</span> is maximal. Then save <span class="math inline">\(u_{m+1}=u_{m+1}'/\|u_{m+1}'\|\)</span>
with the <span class="math inline">\(u_{m+1}'\)</span> from the
optimal <span class="math inline">\(s\)</span>.</p>
This can again be made faster (note <span class="math inline">\(Q^T =
Q\)</span>): For all candidate splits <span class="math inline">\(s\)</span>, let <span class="math inline">\(e_{m+1} = e_{m+1}^s\)</span> be the encoding of
this split. For all <span class="math inline">\(s\)</span>, do
<p>Choose <span class="math inline">\(s\)</span>, such that <span class="math inline">\(\alpha_s\)</span> is maximal. Then save <span class="math inline">\(u_{m+1}=u_{m+1}'/\|u_{m+1}'\|\)</span>
with the <span class="math inline">\(u_{m+1}'\)</span> from the
optimal <span class="math inline">\(s\)</span>. This should be faster
since <span class="math inline">\(Qu_1, \ldots, Qu_m\)</span> only have
to be calculated once.</p>
This can again be rewritten. We use <span class="math inline">\((e_{m+1}^TQu_j)u_j=u_j u_j^TQ e_{m+1}\)</span>.
Hence, we can replace the first line by
<p>Hence, <span class="math inline">\(\left(Q-\sum_{l=1}^m u_l u_l^T
Q\right)\)</span> is always the same and only needs to be updated by
subtracting <span class="math inline">\(u_{m+1} u_{m+1}^T Q\)</span>,
once the best split is decided. Hence, what is remained to do for each
candidate split is really just the matrix vector product <span class="math inline">\(\left(Q -\sum_{l=1}^m u_l u_l^T Q\right)
e_{m+1}\)</span> and the scalar product <span class="math inline">\((u_{m+1}'^TQY)^2/\|u_{m+1}'\|^2\)</span>
in step 2.</p>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-Breiman2017ClassificationTrees" class="csl-entry">
Breiman, Leo, Jerome H. Friedman, Richard A. Olshen, and Charles J.
Stone. 2017. <em><span>Classification And Regression Trees</span></em>.
Routledge. <a href="https://doi.org/10.1201/9781315139470" class="external-link">https://doi.org/10.1201/9781315139470</a>.
</div>
</div>
</div>
  </main>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Markus Ulmer.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.9.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
